{"version":3,"sources":["../src/utils.ts","../src/generator.ts"],"sourcesContent":["import { readFile } from \"fs/promises\";\nimport { load } from \"js-yaml\";\nimport type { RoutingConfig, RouteConfig, SupportedLocale } from \"./types\";\n\nexport async function loadRoutingConfig(configPath: string = \"routes.yml\"): Promise<RoutingConfig> {\n    try {\n        const yamlContent = await readFile(configPath, \"utf-8\");\n        const config = load(yamlContent) as RoutingConfig;\n        return config;\n    } catch (error) {\n        throw new Error(`Failed to load routing configuration from ${configPath}: ${error}`);\n    }\n}\n\nexport function isRouteConfig(value: any): value is RouteConfig {\n    return !!value && typeof value === \"object\" && !!(value.path || value.component);\n}\n\nexport function convertYamlPathToTanstackPath(yamlPath: string): string {\n    // Convert {param} to $param for TanStack Router\n    return yamlPath.replace(/\\{([^}]+)\\}/g, \"$$$1\");\n}\n\nexport function convertYamlPathToReactRouterPath(yamlPath: string): string {\n    // Convert {param} to :param for React Router\n    return yamlPath.replace(/\\{([^}]+)\\}/g, \":$1\");\n}\n\nexport function generateRouteId(routeName: string): string {\n    // Convert snake_case to camelCase for valid JavaScript variable names\n    return routeName.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\nexport function generateComponentImportPath(componentPath: string): string {\n    // Remove .tsx extension if present and ensure it starts with ./\n    const cleanPath = componentPath.replace(/\\.tsx?$/, \"\");\n    return cleanPath.startsWith(\"./\") ? cleanPath : `./${cleanPath}`;\n}\n\nexport function extractPathValue(pathConfig: string | Record<string, string>, locale: string, defaultLocale: string): string {\n    if (typeof pathConfig === \"string\") {\n        return pathConfig;\n    }\n\n    // Return localized path if available, otherwise fall back to default locale, then first available\n    return pathConfig[locale] || pathConfig[defaultLocale] || Object.values(pathConfig)[0] || \"/\";\n}\n\nexport function extractComponentValue(componentConfig: string | Record<string, string>, locale: string, defaultLocale: string): string {\n    if (typeof componentConfig === \"string\") {\n        return componentConfig;\n    }\n\n    // Return localized component if available, otherwise fall back to default locale, then first available\n    return componentConfig[locale] || componentConfig[defaultLocale] || Object.values(componentConfig)[0] || \"pages/NotFound\";\n}\n\nexport function normalizeRouteName(routeName: string): string {\n    return routeName.trim().toLowerCase();\n}\n\nexport function validateRoutingConfig(config: RoutingConfig): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n    const routeNames = new Set<string>();\n\n    for (const [routeName, routeConfig] of Object.entries(config)) {\n        if (routeName === \"settings\") continue;\n\n        if (!isRouteConfig(routeConfig)) {\n            errors.push(`Invalid route configuration for \"${routeName}\"`);\n            continue;\n        }\n\n        const normalizedName = normalizeRouteName(routeName);\n        if (routeNames.has(normalizedName)) {\n            errors.push(`Duplicate route name: \"${routeName}\" (normalized: \"${normalizedName}\")`);\n        }\n        routeNames.add(normalizedName);\n\n        if (!routeConfig.path) {\n            errors.push(`Route \"${routeName}\" is missing required \"path\" property`);\n        }\n\n        if (!routeConfig.component) {\n            errors.push(`Route \"${routeName}\" is missing required \"component\" property`);\n        }\n    }\n\n    return {\n        valid: errors.length === 0,\n        errors,\n    };\n}\n","import { writeFile, readFile } from \"fs/promises\";\nimport { fileURLToPath } from \"url\";\nimport type { RoutingConfig, GeneratedRoute, Settings, SupportedLocale, BuildConfig } from \"./types\";\nimport {\n    loadRoutingConfig,\n    isRouteConfig,\n    convertYamlPathToTanstackPath,\n    generateRouteId,\n    generateComponentImportPath,\n    extractPathValue,\n    extractComponentValue,\n    normalizeRouteName,\n    validateRoutingConfig,\n} from \"./utils\";\n\nclass CodeBuilder {\n    private chunks: string[] = [];\n\n    section(content: string, condition = true): this {\n        if (condition && content.trim()) {\n            this.chunks.push(content.trim());\n        }\n        return this;\n    }\n\n    render(): string {\n        return this.chunks.join(\"\\n\\n\") + \"\\n\";\n    }\n}\n\n// generator templates\nconst $ = {\n    imports: (components: string[], hasI18n: boolean, lazyComponents: boolean = false, routerConfig?: any) => {\n        let routerComponentImports = \"\";\n\n        // Add imports for router components\n        if (routerConfig) {\n            for (const [key, value] of Object.entries(routerConfig)) {\n                if (key.toLowerCase().includes(\"component\") && typeof value === \"string\") {\n                    // Generate PascalCase component name from full path to prevent conflicts\n                    // Example: \"pages/demo/Home\" -> \"PagesDemoHome\"\n                    const componentName = value\n                        .split(\"/\")\n                        .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, \"\"))\n                        .join(\"\");\n\n                    if (lazyComponents) {\n                        routerComponentImports += `\\nconst ${componentName} = lazy(() => import('./${value}'));`;\n                    } else {\n                        routerComponentImports += `\\nimport ${componentName} from './${value}';`;\n                    }\n                }\n            }\n        }\n\n        return `// Auto-generated by yaml-routes\nimport { createRootRoute, createRoute, createRouter } from '@tanstack/react-router';${\n            lazyComponents\n                ? `\nimport { lazy } from 'react';`\n                : \"\"\n        }\nimport { RootComponent } from './App';${\n            hasI18n\n                ? `\nimport { useState, useEffect } from 'react';\nimport { useLocation, useMatchRoute, useParams } from '@tanstack/react-router';`\n                : \"\"\n        }\n${components.join(\"\\n\")}${routerComponentImports}`;\n    },\n\n    settings: (config: any) => `export const settings = ${JSON.stringify(config, null, 2)};`,\n\n    i18nCode: (config: { default: string; locales: string[]; forceUrl: boolean; basePath?: string }, mappings: any = {}) => `// üåç Smart i18n system\nexport const pathMappings: Record<string, Record<string, string>> = ${JSON.stringify(mappings, null, 2)};\n\nexport function getLocalizedPath(path: string, locale: string): string {\n  return pathMappings[path]?.[locale] || path;\n}\n\nexport function useCurrentLocale(): string {\n  const location = useLocation();\n  \n  // Get current locale from TanStack Router location (reactive)\n  let currentPath = location.pathname;\n  ${\n      config.basePath\n          ? `const basePath = '${config.basePath}';\n  if (currentPath.startsWith(basePath)) {\n    currentPath = currentPath.slice(basePath.length) || '/';\n  }`\n          : \"\"\n  }\n  \n  // Detect locale from URL path\n  const supportedLocales = ${JSON.stringify(config.locales)};\n  const detectedLocale = supportedLocales.find(loc => \n    loc !== settings.i18n.defaultLocale && (\n      currentPath.startsWith('/' + loc + '/') || \n      currentPath === '/' + loc || \n      currentPath === '/' + loc + '/'\n    )\n  );\n  \n  return detectedLocale || settings.i18n.defaultLocale;\n}\n\nexport function useRouteTo(): RouteToFunction {\n  const locale = useCurrentLocale();\n  return <K extends RouteNames>(\n    id: K,\n    ...params: RouteToParams<ExtractParams<K>>\n  ): string => {\n    const route = routeIdMappings[id.toLowerCase() as string];\n    if (!route) return '/';\n    \n    // Get the localized path template\n    const localizedTemplate = getLocalizedPath(route.path, locale);\n    \n    // Fill in parameters\n    let finalPath = localizedTemplate;\n    const paramObj = params[0] || {};\n    Object.entries(paramObj).forEach(([k, v]) => finalPath = finalPath.replace(\\`{\\${k}}\\`, String(v)));\n    return finalPath;\n  };\n}\n\nexport function useRouteName(): RouteNames | \"unknown\" {\n    const current = useCurrentRoute();\n    return (current?.routeId as RouteNames) ?? \"unknown\";\n}\n\nexport function useRouteParams(includeLocale: boolean = true): Record<string, string> {\n  const params = useParams({ strict: false });\n  const locale = useCurrentLocale();\n  \n  if (includeLocale) {\n    return {\n      ...params,\n      locale\n    };\n  }\n  \n  return params;\n}`,\n\n    routeIdMappings: (mappings: any) =>\n        `export const routeIdMappings: Record<string, { path: string; parameters: string[]; requiredParameters?: string[] }> = ${JSON.stringify(\n            mappings,\n            null,\n            2\n        )};`,\n\n    routeTypes: (mappings: any) => {\n        // Generate TypeScript types for route parameters\n        const routeEntries = Object.entries(mappings);\n\n        // Generate the route parameters interface\n        const paramInterfaces = routeEntries\n            .map(([routeId, mapping]: [string, any]) => {\n                const path = mapping.path as string;\n                const params = path.match(/\\{([^}]+)\\}/g);\n\n                if (!params || params.length === 0) {\n                    return `  '${routeId}': {};`;\n                }\n\n                const paramTypes = params\n                    .map((param) => {\n                        const paramName = param.slice(1, -1); // Remove { and }\n                        return `${paramName}: string`;\n                    })\n                    .join(\"; \");\n\n                return `  '${routeId}': { ${paramTypes} };`;\n            })\n            .join(\"\\n\");\n\n        // Generate route names union type\n        const routeNames = routeEntries.map(([routeId]) => `'${routeId}'`).join(\" | \");\n\n        return `// Type-safe route definitions\nexport interface RouteParams {\n${paramInterfaces}\n}\n\nexport type RouteNames = ${routeNames};\n\n// Type-safe routeTo function types\ntype ExtractParams<T extends RouteNames> = RouteParams[T];\ntype HasRequiredParams<T> = {} extends T ? false : true;\ntype RouteToParams<T> = HasRequiredParams<T> extends true ? [params: T] : [params?: T];\n\nexport type RouteToFunction = <K extends RouteNames>(\n  routeId: K,\n  ...params: RouteToParams<ExtractParams<K>>\n) => string;`;\n    },\n\n    localeSwitcherHelpers: () => {\n        return `\n// üîß Helper functions for locale switching (React hooks only)\n// Required imports: useLocation from '@tanstack/react-router'\n// These functions depend on: settings, pathMappings, routeIdMappings, useRouteTo\n\nexport function extractRouteParameters(url: string, pattern: string): Record<string, string> | null {\n    const regexPattern = pattern.replace(/\\\\{([^}]+)\\\\}/g, \"([^/]+)\");\n    const regex = new RegExp(\\`^\\${regexPattern}$\\`);\n    const match = url.match(regex);\n\n    if (!match) return null;\n\n    const paramNames = [...pattern.matchAll(/\\\\{([^}]+)\\\\}/g)].map((m) => m[1]);\n    const params: Record<string, string> = {};\n    paramNames.forEach((name, index) => {\n        params[name] = match[index + 1];\n    });\n\n    return params;\n}\n\n// üîß React hooks for locale switching (using TanStack Router)\nexport function useCurrentRoute(): { routeId: string; params: Record<string, string> } | null {\n    const location = useLocation();\n\n    // Get current URL path from TanStack Router location (reactive)\n    const currentPath = location.pathname;\n    let pathWithoutBase = currentPath;\n\n    // Remove base path if present\n    if (settings.basePath && currentPath.startsWith(settings.basePath)) {\n        pathWithoutBase = currentPath.slice(settings.basePath.length) || \"/\";\n    }\n\n    // Try to match current path against all route patterns in pathMappings\n    for (const [routePattern, localeMap] of Object.entries(pathMappings)) {\n        for (const [locale, localizedPath] of Object.entries(localeMap)) {\n            const params = extractRouteParameters(pathWithoutBase, localizedPath);\n            if (params !== null) {\n                // Found a match! Find the corresponding route ID\n                const routeId = Object.keys(routeIdMappings).find((id) => routeIdMappings[id].path === routePattern);\n                if (routeId) {\n                    return { routeId, params };\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nexport function useLocalePath(targetLocale: string): string {\n    const currentRoute = useCurrentRoute();\n\n    if (currentRoute) {\n        // Found the current route - generate URL for target locale\n        const routePattern = routeIdMappings[currentRoute.routeId]?.path;\n        if (routePattern && pathMappings[routePattern]?.[targetLocale]) {\n            const targetPath = pathMappings[routePattern][targetLocale];\n            // Replace parameters in the target path\n            let finalPath = targetPath;\n            for (const [key, value] of Object.entries(currentRoute.params)) {\n                finalPath = finalPath.replace('{' + key + '}', value);\n            }\n            return finalPath;\n        }\n    }\n\n    // Fallback: go to home page of target locale\n    const homePattern = routeIdMappings[\"home\"]?.path;\n    if (homePattern && pathMappings[homePattern]?.[targetLocale]) {\n        return pathMappings[homePattern][targetLocale];\n    }\n    \n    return \"/\";\n}`.trim();\n    },\n\n    router: (definitions: string[], routeVariables: string[], basePath?: string, routerConfig?: any) => {\n        const configOptions = [];\n\n        if (basePath) {\n            configOptions.push(`basepath: '${basePath}'`);\n        }\n\n        // Generic handling of all router config options\n        if (routerConfig) {\n            for (const [key, value] of Object.entries(routerConfig)) {\n                if (value !== undefined && value !== null) {\n                    // Handle component references specially\n                    if (key.toLowerCase().includes(\"component\") && typeof value === \"string\") {\n                        // Generate PascalCase component name from full path to prevent conflicts\n                        // Example: \"pages/demo/Home\" -> \"PagesDemoHome\"\n                        const componentName = value\n                            .split(\"/\")\n                            .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, \"\"))\n                            .join(\"\");\n                        configOptions.push(`${key}: ${componentName}`);\n                    } else {\n                        // Regular values\n                        const formattedValue = typeof value === \"string\" ? `'${value}'` : String(value);\n                        configOptions.push(`${key}: ${formattedValue}`);\n                    }\n                }\n            }\n        }\n\n        const configString = configOptions.length > 0 ? `,\\n  ${configOptions.join(\",\\n  \")}` : \"\";\n\n        return `const rootRoute = createRootRoute({ \n  component: RootComponent \n});\n\n${definitions.join(\"\\n\\n\")}\n\n// Export all routes in a convenient array\nexport const routes = [${routeVariables.join(\", \")}];\n\nexport const router = createRouter({\n  routeTree: rootRoute.addChildren(routes)${configString}\n});\n\ndeclare module '@tanstack/react-router' {\n  interface Register { router: typeof router; }\n}`;\n    },\n\n    routesArray: (routeVariables: string[]) => `// Export all routes in a convenient array\nexport const routes = [${routeVariables.join(\", \")}];`,\n};\n\n// üé® Route processor with zero waste\nfunction processRoutes(routes: GeneratedRoute[], config: any) {\n    const { hasI18n, locales, default: defaultLocale, lazyComponents = false } = config;\n    const imports = new Set<string>();\n    const componentNameMap = new Map<string, string>();\n    const routeDefinitions: string[] = [];\n    const routeVariables: string[] = [];\n    const localizedRouteDefinitions: string[] = [];\n    const localizedRouteVariables: string[] = [];\n    const pathMappings: Record<string, Record<string, string>> = {};\n    const routeIdMappings: Record<string, any> = {};\n\n    // Generate imports (collect all unique component paths)\n    routes.forEach((route) => {\n        const allComponents = hasI18n ? Object.values(route.i18nComponents) : [route.component];\n\n        allComponents.forEach((componentPath) => {\n            const importPath = generateComponentImportPath(componentPath);\n\n            // Generate PascalCase component name from full path to prevent conflicts\n            // Example: \"pages/demo/Home\" -> \"PagesDemoHome\"\n            const componentName = componentPath\n                .split(\"/\")\n                .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, \"\"))\n                .join(\"\");\n\n            if (lazyComponents) {\n                imports.add(`const ${componentName} = lazy(() => import('${importPath}'));`);\n            } else {\n                imports.add(`import ${componentName} from '${importPath}';`);\n            }\n            componentNameMap.set(componentPath, componentName);\n        });\n    });\n\n    // Generate route definitions for default locale\n    routes.forEach((route) => {\n        const componentName = componentNameMap.get(route.component) || \"Component\";\n        const routeVarName = `${generateRouteId(route.id)}Route`; // Use camelCase for variable names\n        const routePath = convertYamlPathToTanstackPath(route.path);\n\n        routeDefinitions.push(`const ${routeVarName} = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '${routePath}',\n  component: ${componentName}\n});`);\n\n        routeVariables.push(routeVarName);\n    });\n\n    // Generate localized route definitions with locale prefix (only if i18n is enabled)\n    if (hasI18n) {\n        (locales as string[]).forEach((locale: string) => {\n            if (locale === defaultLocale) return; // Skip default locale as it has no prefix\n\n            routes.forEach((route) => {\n                const componentPath = route.i18nComponents[locale] || route.component;\n                const componentName = componentNameMap.get(componentPath) || \"Component\";\n                const routeVarName = `${generateRouteId(route.id)}${locale.charAt(0).toUpperCase() + locale.slice(1)}Route`;\n\n                // Use the localized path from i18n config if available, otherwise use the base path\n                const localizedPath = route.i18nPaths[locale] || route.path;\n                const convertedPath = convertYamlPathToTanstackPath(localizedPath);\n\n                // Add locale prefix to the localized path\n                const finalPath = `/${locale}${convertedPath}`;\n\n                localizedRouteDefinitions.push(`const ${routeVarName} = createRoute({\n  getParentRoute: () => rootRoute,\n  path: '${finalPath}',\n  component: ${componentName}\n});`);\n\n                localizedRouteVariables.push(routeVarName);\n            });\n        });\n    }\n\n    // Generate path mapping for navigation (only if i18n is enabled)\n    if (hasI18n) {\n        routes.forEach((route) => {\n            const basePath = route.path;\n            pathMappings[basePath] = {};\n            (locales as string[]).forEach((locale: string) => {\n                if (locale === defaultLocale) {\n                    pathMappings[basePath][locale] = basePath;\n                } else {\n                    const localizedPath = route.i18nPaths[locale] || route.path;\n                    pathMappings[basePath][locale] = `/${locale}${localizedPath}`;\n                }\n            });\n        });\n    }\n\n    // Generate route ID mapping for the routeTo helper\n    routes.forEach((route) => {\n        const paramNames = Object.keys(route.parameters);\n        const requiredParams = paramNames.filter((name) => route.parameters[name]?.required);\n\n        // Only use the original YAML key - developers should use the same convention\n        routeIdMappings[route.id] = {\n            path: route.path,\n            parameters: paramNames,\n            requiredParameters: requiredParams,\n        };\n    });\n\n    // Build the route tree\n    const allRouteVariables = [...routeVariables, ...localizedRouteVariables];\n    const allDefinitions = [...routeDefinitions, ...localizedRouteDefinitions];\n\n    return {\n        components: Array.from(imports),\n        definitions: allDefinitions,\n        routeVariables: allRouteVariables,\n        pathMappings,\n        routeIdMappings,\n        config: { hasI18n, forceUrl: config.forceUrl, default: defaultLocale, locales, basePath: config.basePath },\n    };\n}\n\nexport async function generateTanStackRoutes(config: BuildConfig): Promise<void> {\n    console.log(\"üîß Loading configuration...\");\n    const routingConfig = await loadRoutingConfig(config.configPath);\n\n    const validation = validateRoutingConfig(routingConfig);\n    if (!validation.valid) {\n        throw new Error(`‚ùå Invalid config:\\n${validation.errors.join(\"\\n\")}`);\n    }\n\n    console.log(\"üöÄ Processing routes...\");\n\n    // Extract settings\n    const settings = routingConfig.settings || {};\n    const i18nEnabled = settings.i18n?.enabled ?? true;\n    const defaultLocale = settings.i18n?.defaultLocale || config.defaultLocale || \"en\";\n    const supportedLocales = settings.i18n?.supportedLocales || config.supportedLocales || [\"en\", \"fr\", \"es\"];\n    const forceLocaleUrl = settings.i18n?.forceLocaleUrl ?? false;\n    const lazyComponents = settings.lazyComponents ?? false;\n    const routerConfig = settings.router || {};\n\n    console.log(`üåê i18n: ${i18nEnabled ? \"enabled\" : \"disabled\"}, locale: ${defaultLocale}, force: ${forceLocaleUrl}`);\n    console.log(`‚ö° Lazy components: ${lazyComponents ? \"enabled\" : \"disabled\"}`);\n    if (Object.keys(routerConfig).length > 0) {\n        console.log(`üöÄ Router config: ${Object.keys(routerConfig).join(\", \")}`);\n    }\n\n    // Process routes\n    const routes: GeneratedRoute[] = [];\n    for (const [name, routeConfig] of Object.entries(routingConfig)) {\n        if (name === \"settings\" || !isRouteConfig(routeConfig)) continue;\n\n        const normalizedName = normalizeRouteName(name);\n\n        const i18nPaths: Record<string, string> = {};\n        const i18nComponents: Record<string, string> = {};\n\n        if (i18nEnabled) {\n            for (const locale of supportedLocales) {\n                i18nPaths[locale] = extractPathValue(routeConfig.path, locale, defaultLocale);\n                i18nComponents[locale] = extractComponentValue(routeConfig.component, locale, defaultLocale);\n            }\n        } else {\n            const path = extractPathValue(routeConfig.path, defaultLocale, defaultLocale);\n            const component = extractComponentValue(routeConfig.component, defaultLocale, defaultLocale);\n            i18nPaths[defaultLocale] = path;\n            i18nComponents[defaultLocale] = component;\n        }\n\n        routes.push({\n            id: normalizedName,\n            path: extractPathValue(routeConfig.path, defaultLocale, defaultLocale),\n            component: extractComponentValue(routeConfig.component, defaultLocale, defaultLocale),\n            parameters: routeConfig.parameters || {},\n            i18nPaths,\n            i18nComponents,\n            settings: routeConfig.settings,\n        });\n    }\n\n    // Process and generate\n    const routeConfig = {\n        hasI18n: i18nEnabled,\n        locales: supportedLocales,\n        default: defaultLocale,\n        forceUrl: forceLocaleUrl,\n        basePath: settings.basePath,\n        lazyComponents,\n    };\n    const processed = processRoutes(routes, routeConfig);\n\n    // Build final code\n    const code = new CodeBuilder()\n        .section($.imports(processed.components, i18nEnabled, lazyComponents, routerConfig))\n        .section($.settings(settings))\n        .section($.routeTypes(processed.routeIdMappings))\n        .section($.i18nCode(processed.config, processed.pathMappings), i18nEnabled)\n        .section($.routeIdMappings(processed.routeIdMappings))\n        .section($.localeSwitcherHelpers(), i18nEnabled)\n        .section($.router(processed.definitions, processed.routeVariables, settings.basePath, routerConfig))\n        .render();\n\n    await writeFile(config.outputPath, code);\n\n    console.log(`‚úÖ Generated: ${config.outputPath}`);\n    console.log(`üìä Routes: ${routes.length}${i18nEnabled ? ` (i18n enabled)` : \"\"}`);\n    console.log(\"üéâ Complete!\");\n}\n"],"mappings":"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","names":["routeConfig"]}