// src/utils.ts
import { readFile } from "fs/promises";
import { load } from "js-yaml";
async function loadRoutingConfig(configPath = "routes.yml") {
  try {
    const yamlContent = await readFile(configPath, "utf-8");
    const config = load(yamlContent);
    return config;
  } catch (error) {
    throw new Error(`Failed to load routing configuration from ${configPath}: ${error}`);
  }
}
function isRouteConfig(value) {
  return !!value && typeof value === "object" && !!(value.path || value.component);
}
function convertYamlPathToTanstackPath(yamlPath) {
  return yamlPath.replace(/\{([^}]+)\}/g, "$$$1");
}
function convertYamlPathToReactRouterPath(yamlPath) {
  return yamlPath.replace(/\{([^}]+)\}/g, ":$1");
}
function generateRouteId(routeName) {
  return routeName.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}
function generateComponentImportPath(componentPath) {
  const cleanPath = componentPath.replace(/\.tsx?$/, "");
  return cleanPath.startsWith("./") ? cleanPath : `./${cleanPath}`;
}
function extractPathValue(pathConfig, locale, defaultLocale) {
  if (typeof pathConfig === "string") {
    return pathConfig;
  }
  return pathConfig[locale] || pathConfig[defaultLocale] || Object.values(pathConfig)[0] || "/";
}
function extractComponentValue(componentConfig, locale, defaultLocale) {
  if (typeof componentConfig === "string") {
    return componentConfig;
  }
  return componentConfig[locale] || componentConfig[defaultLocale] || Object.values(componentConfig)[0] || "pages/NotFound";
}
function normalizeRouteName(routeName) {
  return routeName.trim().toLowerCase();
}
function validateRoutingConfig(config) {
  const errors = [];
  const routeNames = /* @__PURE__ */ new Set();
  for (const [routeName, routeConfig] of Object.entries(config)) {
    if (routeName === "settings") continue;
    if (!isRouteConfig(routeConfig)) {
      errors.push(`Invalid route configuration for "${routeName}"`);
      continue;
    }
    const normalizedName = normalizeRouteName(routeName);
    if (routeNames.has(normalizedName)) {
      errors.push(`Duplicate route name: "${routeName}" (normalized: "${normalizedName}")`);
    }
    routeNames.add(normalizedName);
    if (!routeConfig.path) {
      errors.push(`Route "${routeName}" is missing required "path" property`);
    }
    if (!routeConfig.component) {
      errors.push(`Route "${routeName}" is missing required "component" property`);
    }
  }
  return {
    valid: errors.length === 0,
    errors
  };
}

// src/generator.ts
import { writeFile } from "fs/promises";
var CodeBuilder = class {
  chunks = [];
  section(content, condition = true) {
    if (condition && content.trim()) {
      this.chunks.push(content.trim());
    }
    return this;
  }
  render() {
    return this.chunks.join("\n\n") + "\n";
  }
};
var $ = {
  imports: (components, hasI18n, lazyComponents = false, routerConfig) => {
    let routerComponentImports = "";
    if (routerConfig) {
      for (const [key, value] of Object.entries(routerConfig)) {
        if (key.toLowerCase().includes("component") && typeof value === "string") {
          const componentName = value.split("/").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, "")).join("");
          if (lazyComponents) {
            routerComponentImports += `
const ${componentName} = lazy(() => import('./${value}'));`;
          } else {
            routerComponentImports += `
import ${componentName} from './${value}';`;
          }
        }
      }
    }
    return `// Auto-generated by yaml-routes
import { createRootRoute, createRoute, createRouter } from '@tanstack/react-router';${lazyComponents ? `
import { lazy } from 'react';` : ""}
import { RootComponent } from './App';${hasI18n ? `
import { useState, useEffect } from 'react';
import { useLocation, useMatchRoute, useParams } from '@tanstack/react-router';` : ""}
${components.join("\n")}${routerComponentImports}`;
  },
  settings: (config) => `export const settings = ${JSON.stringify(config, null, 2)};`,
  i18nCode: (config, mappings = {}) => `// \u{1F30D} Smart i18n system
export const pathMappings: Record<string, Record<string, string>> = ${JSON.stringify(mappings, null, 2)};

export function getLocalizedPath(path: string, locale: string): string {
  return pathMappings[path]?.[locale] || path;
}

export function useCurrentLocale(): string {
  const location = useLocation();
  
  // Get current locale from TanStack Router location (reactive)
  let currentPath = location.pathname;
  ${config.basePath ? `const basePath = '${config.basePath}';
  if (currentPath.startsWith(basePath)) {
    currentPath = currentPath.slice(basePath.length) || '/';
  }` : ""}
  
  // Detect locale from URL path
  const supportedLocales = ${JSON.stringify(config.locales)};
  const detectedLocale = supportedLocales.find(loc => 
    loc !== settings.i18n.defaultLocale && (
      currentPath.startsWith('/' + loc + '/') || 
      currentPath === '/' + loc || 
      currentPath === '/' + loc + '/'
    )
  );
  
  return detectedLocale || settings.i18n.defaultLocale;
}

export function useRouteTo(): RouteToFunction {
  const locale = useCurrentLocale();
  return <K extends RouteNames>(
    id: K,
    ...params: RouteToParams<ExtractParams<K>>
  ): string => {
    const route = routeIdMappings[id.toLowerCase() as string];
    if (!route) return '/';
    
    // Get the localized path template
    const localizedTemplate = getLocalizedPath(route.path, locale);
    
    // Fill in parameters
    let finalPath = localizedTemplate;
    const paramObj = params[0] || {};
    Object.entries(paramObj).forEach(([k, v]) => finalPath = finalPath.replace(\`{\${k}}\`, String(v)));
    return finalPath;
  };
}

export function useRouteName(): RouteNames | "unknown" {
    const current = useCurrentRoute();
    return (current?.routeId as RouteNames) ?? "unknown";
}

export function useRouteParams(includeLocale: boolean = true): Record<string, string> {
  const params = useParams({ strict: false });
  const locale = useCurrentLocale();
  
  if (includeLocale) {
    return {
      ...params,
      locale
    };
  }
  
  return params;
}`,
  routeIdMappings: (mappings) => `export const routeIdMappings: Record<string, { path: string; parameters: string[]; requiredParameters?: string[] }> = ${JSON.stringify(
    mappings,
    null,
    2
  )};`,
  routeTypes: (mappings) => {
    const routeEntries = Object.entries(mappings);
    const paramInterfaces = routeEntries.map(([routeId, mapping]) => {
      const path = mapping.path;
      const params = path.match(/\{([^}]+)\}/g);
      if (!params || params.length === 0) {
        return `  '${routeId}': {};`;
      }
      const paramTypes = params.map((param) => {
        const paramName = param.slice(1, -1);
        return `${paramName}: string`;
      }).join("; ");
      return `  '${routeId}': { ${paramTypes} };`;
    }).join("\n");
    const routeNames = routeEntries.map(([routeId]) => `'${routeId}'`).join(" | ");
    return `// Type-safe route definitions
export interface RouteParams {
${paramInterfaces}
}

export type RouteNames = ${routeNames};

// Type-safe routeTo function types
type ExtractParams<T extends RouteNames> = RouteParams[T];
type HasRequiredParams<T> = {} extends T ? false : true;
type RouteToParams<T> = HasRequiredParams<T> extends true ? [params: T] : [params?: T];

export type RouteToFunction = <K extends RouteNames>(
  routeId: K,
  ...params: RouteToParams<ExtractParams<K>>
) => string;`;
  },
  localeSwitcherHelpers: () => {
    return `
// \u{1F527} Helper functions for locale switching (React hooks only)
// Required imports: useLocation from '@tanstack/react-router'
// These functions depend on: settings, pathMappings, routeIdMappings, useRouteTo

export function extractRouteParameters(url: string, pattern: string): Record<string, string> | null {
    const regexPattern = pattern.replace(/\\{([^}]+)\\}/g, "([^/]+)");
    const regex = new RegExp(\`^\${regexPattern}$\`);
    const match = url.match(regex);

    if (!match) return null;

    const paramNames = [...pattern.matchAll(/\\{([^}]+)\\}/g)].map((m) => m[1]);
    const params: Record<string, string> = {};
    paramNames.forEach((name, index) => {
        params[name] = match[index + 1];
    });

    return params;
}

// \u{1F527} React hooks for locale switching (using TanStack Router)
export function useCurrentRoute(): { routeId: string; params: Record<string, string> } | null {
    const location = useLocation();

    // Get current URL path from TanStack Router location (reactive)
    const currentPath = location.pathname;
    let pathWithoutBase = currentPath;

    // Remove base path if present
    if (settings.basePath && currentPath.startsWith(settings.basePath)) {
        pathWithoutBase = currentPath.slice(settings.basePath.length) || "/";
    }

    // Try to match current path against all route patterns in pathMappings
    for (const [routePattern, localeMap] of Object.entries(pathMappings)) {
        for (const [locale, localizedPath] of Object.entries(localeMap)) {
            const params = extractRouteParameters(pathWithoutBase, localizedPath);
            if (params !== null) {
                // Found a match! Find the corresponding route ID
                const routeId = Object.keys(routeIdMappings).find((id) => routeIdMappings[id].path === routePattern);
                if (routeId) {
                    return { routeId, params };
                }
            }
        }
    }

    return null;
}

export function useLocalePath(targetLocale: string): string {
    const currentRoute = useCurrentRoute();

    if (currentRoute) {
        // Found the current route - generate URL for target locale
        const routePattern = routeIdMappings[currentRoute.routeId]?.path;
        if (routePattern && pathMappings[routePattern]?.[targetLocale]) {
            const targetPath = pathMappings[routePattern][targetLocale];
            // Replace parameters in the target path
            let finalPath = targetPath;
            for (const [key, value] of Object.entries(currentRoute.params)) {
                finalPath = finalPath.replace('{' + key + '}', value);
            }
            return finalPath;
        }
    }

    // Fallback: go to home page of target locale
    const homePattern = routeIdMappings["home"]?.path;
    if (homePattern && pathMappings[homePattern]?.[targetLocale]) {
        return pathMappings[homePattern][targetLocale];
    }
    
    return "/";
}`.trim();
  },
  router: (definitions, routeVariables, basePath, routerConfig) => {
    const configOptions = [];
    if (basePath) {
      configOptions.push(`basepath: '${basePath}'`);
    }
    if (routerConfig) {
      for (const [key, value] of Object.entries(routerConfig)) {
        if (value !== void 0 && value !== null) {
          if (key.toLowerCase().includes("component") && typeof value === "string") {
            const componentName = value.split("/").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, "")).join("");
            configOptions.push(`${key}: ${componentName}`);
          } else {
            const formattedValue = typeof value === "string" ? `'${value}'` : String(value);
            configOptions.push(`${key}: ${formattedValue}`);
          }
        }
      }
    }
    const configString = configOptions.length > 0 ? `,
  ${configOptions.join(",\n  ")}` : "";
    return `const rootRoute = createRootRoute({ 
  component: RootComponent 
});

${definitions.join("\n\n")}

// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];

export const router = createRouter({
  routeTree: rootRoute.addChildren(routes)${configString}
});

declare module '@tanstack/react-router' {
  interface Register { router: typeof router; }
}`;
  },
  routesArray: (routeVariables) => `// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];`
};
function processRoutes(routes, config) {
  const { hasI18n, locales, default: defaultLocale, lazyComponents = false } = config;
  const imports = /* @__PURE__ */ new Set();
  const componentNameMap = /* @__PURE__ */ new Map();
  const routeDefinitions = [];
  const routeVariables = [];
  const localizedRouteDefinitions = [];
  const localizedRouteVariables = [];
  const pathMappings = {};
  const routeIdMappings = {};
  routes.forEach((route) => {
    const allComponents = hasI18n ? Object.values(route.i18nComponents) : [route.component];
    allComponents.forEach((componentPath) => {
      const importPath = generateComponentImportPath(componentPath);
      const componentName = componentPath.split("/").map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, "")).join("");
      if (lazyComponents) {
        imports.add(`const ${componentName} = lazy(() => import('${importPath}'));`);
      } else {
        imports.add(`import ${componentName} from '${importPath}';`);
      }
      componentNameMap.set(componentPath, componentName);
    });
  });
  routes.forEach((route) => {
    const componentName = componentNameMap.get(route.component) || "Component";
    const routeVarName = `${generateRouteId(route.id)}Route`;
    const routePath = convertYamlPathToTanstackPath(route.path);
    routeDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${routePath}',
  component: ${componentName}
});`);
    routeVariables.push(routeVarName);
  });
  if (hasI18n) {
    locales.forEach((locale) => {
      if (locale === defaultLocale) return;
      routes.forEach((route) => {
        const componentPath = route.i18nComponents[locale] || route.component;
        const componentName = componentNameMap.get(componentPath) || "Component";
        const routeVarName = `${generateRouteId(route.id)}${locale.charAt(0).toUpperCase() + locale.slice(1)}Route`;
        const localizedPath = route.i18nPaths[locale] || route.path;
        const convertedPath = convertYamlPathToTanstackPath(localizedPath);
        const finalPath = `/${locale}${convertedPath}`;
        localizedRouteDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${finalPath}',
  component: ${componentName}
});`);
        localizedRouteVariables.push(routeVarName);
      });
    });
  }
  if (hasI18n) {
    routes.forEach((route) => {
      const basePath = route.path;
      pathMappings[basePath] = {};
      locales.forEach((locale) => {
        if (locale === defaultLocale) {
          pathMappings[basePath][locale] = basePath;
        } else {
          const localizedPath = route.i18nPaths[locale] || route.path;
          pathMappings[basePath][locale] = `/${locale}${localizedPath}`;
        }
      });
    });
  }
  routes.forEach((route) => {
    const paramNames = Object.keys(route.parameters);
    const requiredParams = paramNames.filter((name) => route.parameters[name]?.required);
    routeIdMappings[route.id] = {
      path: route.path,
      parameters: paramNames,
      requiredParameters: requiredParams
    };
  });
  const allRouteVariables = [...routeVariables, ...localizedRouteVariables];
  const allDefinitions = [...routeDefinitions, ...localizedRouteDefinitions];
  return {
    components: Array.from(imports),
    definitions: allDefinitions,
    routeVariables: allRouteVariables,
    pathMappings,
    routeIdMappings,
    config: { hasI18n, forceUrl: config.forceUrl, default: defaultLocale, locales, basePath: config.basePath }
  };
}
async function generateTanStackRoutes(config) {
  console.log("\u{1F527} Loading configuration...");
  const routingConfig = await loadRoutingConfig(config.configPath);
  const validation = validateRoutingConfig(routingConfig);
  if (!validation.valid) {
    throw new Error(`\u274C Invalid config:
${validation.errors.join("\n")}`);
  }
  console.log("\u{1F680} Processing routes...");
  const settings = routingConfig.settings || {};
  const i18nEnabled = settings.i18n?.enabled ?? true;
  const defaultLocale = settings.i18n?.defaultLocale || config.defaultLocale || "en";
  const supportedLocales = settings.i18n?.supportedLocales || config.supportedLocales || ["en", "fr", "es"];
  const forceLocaleUrl = settings.i18n?.forceLocaleUrl ?? false;
  const lazyComponents = settings.lazyComponents ?? false;
  const routerConfig = settings.router || {};
  console.log(`\u{1F310} i18n: ${i18nEnabled ? "enabled" : "disabled"}, locale: ${defaultLocale}, force: ${forceLocaleUrl}`);
  console.log(`\u26A1 Lazy components: ${lazyComponents ? "enabled" : "disabled"}`);
  if (Object.keys(routerConfig).length > 0) {
    console.log(`\u{1F680} Router config: ${Object.keys(routerConfig).join(", ")}`);
  }
  const routes = [];
  for (const [name, routeConfig2] of Object.entries(routingConfig)) {
    if (name === "settings" || !isRouteConfig(routeConfig2)) continue;
    const normalizedName = normalizeRouteName(name);
    const i18nPaths = {};
    const i18nComponents = {};
    if (i18nEnabled) {
      for (const locale of supportedLocales) {
        i18nPaths[locale] = extractPathValue(routeConfig2.path, locale, defaultLocale);
        i18nComponents[locale] = extractComponentValue(routeConfig2.component, locale, defaultLocale);
      }
    } else {
      const path = extractPathValue(routeConfig2.path, defaultLocale, defaultLocale);
      const component = extractComponentValue(routeConfig2.component, defaultLocale, defaultLocale);
      i18nPaths[defaultLocale] = path;
      i18nComponents[defaultLocale] = component;
    }
    routes.push({
      id: normalizedName,
      path: extractPathValue(routeConfig2.path, defaultLocale, defaultLocale),
      component: extractComponentValue(routeConfig2.component, defaultLocale, defaultLocale),
      parameters: routeConfig2.parameters || {},
      i18nPaths,
      i18nComponents,
      settings: routeConfig2.settings
    });
  }
  const routeConfig = {
    hasI18n: i18nEnabled,
    locales: supportedLocales,
    default: defaultLocale,
    forceUrl: forceLocaleUrl,
    basePath: settings.basePath,
    lazyComponents
  };
  const processed = processRoutes(routes, routeConfig);
  const code = new CodeBuilder().section($.imports(processed.components, i18nEnabled, lazyComponents, routerConfig)).section($.settings(settings)).section($.routeTypes(processed.routeIdMappings)).section($.i18nCode(processed.config, processed.pathMappings), i18nEnabled).section($.routeIdMappings(processed.routeIdMappings)).section($.localeSwitcherHelpers(), i18nEnabled).section($.router(processed.definitions, processed.routeVariables, settings.basePath, routerConfig)).render();
  await writeFile(config.outputPath, code);
  console.log(`\u2705 Generated: ${config.outputPath}`);
  console.log(`\u{1F4CA} Routes: ${routes.length}${i18nEnabled ? ` (i18n enabled)` : ""}`);
  console.log("\u{1F389} Complete!");
}

export {
  loadRoutingConfig,
  isRouteConfig,
  convertYamlPathToTanstackPath,
  convertYamlPathToReactRouterPath,
  generateRouteId,
  generateComponentImportPath,
  extractPathValue,
  extractComponentValue,
  normalizeRouteName,
  validateRoutingConfig,
  generateTanStackRoutes
};
//# sourceMappingURL=chunk-56RHWCFF.js.map