import { writeFile } from "fs/promises";
import type { RoutingConfig, GeneratedRoute, GlobalSettings, SupportedLocale, BuildConfig } from "./types";
import {
    loadRoutingConfig,
    isRouteConfig,
    convertYamlPathToTanstackPath,
    generateRouteId,
    generateComponentImportPath,
    extractPathValue,
    extractComponentValue,
    normalizeRouteName,
    validateRoutingConfig,
} from "./utils";

// 🚀 Ultra-clean template system - zero boilerplate, maximum power
class CodeBuilder {
    private chunks: string[] = [];

    section(content: string, condition = true): this {
        if (condition && content.trim()) {
            this.chunks.push(content.trim());
        }
        return this;
    }

    render(): string {
        return this.chunks.join("\n\n") + "\n";
    }
}

// 🎯 Smart templates that adapt to configuration
const $ = {
    imports: (components: string[], hasI18n: boolean, lazyComponents: boolean = false) => `// Auto-generated by yaml-routes
import { createRootRoute, createRoute, createRouter } from '@tanstack/react-router';${
        lazyComponents
            ? `
import { lazy } from 'react';`
            : ""
    }
import { RootComponent } from './App';${
        hasI18n
            ? `
import { useState, useEffect } from 'react';
import { useLocation } from '@tanstack/react-router';`
            : ""
    }
${components.join("\n")}`,

    settings: (config: any) => `export const globalSettings = ${JSON.stringify(config, null, 2)};`,

    i18nCode: (config: { default: string; locales: string[]; forceUrl: boolean; basePath?: string }, mappings: any = {}) => `// 🌍 Smart i18n system
export const pathMappings = ${JSON.stringify(mappings, null, 2)};

export function getCurrentLocale(): string {
  ${
      config.forceUrl
          ? `try {
    // Get current URL path
    const currentPath = window.location.pathname;
    let pathWithoutBase = currentPath;
    
    // Remove base path if present
    ${
        config.basePath
            ? `const basePath = '${config.basePath}';
    if (currentPath.startsWith(basePath)) {
      pathWithoutBase = currentPath.slice(basePath.length) || '/';
    }`
            : ""
    }
    
    // Detect locale from URL path
    const supportedLocales = ${JSON.stringify(config.locales)};
    const detectedLocale = supportedLocales.find(loc => 
      loc !== '${config.default}' && (
        pathWithoutBase.startsWith('/' + loc + '/') || 
        pathWithoutBase === '/' + loc || 
        pathWithoutBase === '/' + loc + '/'
      )
    );
    
    return detectedLocale || '${config.default}';
  } catch {
    return '${config.default}';
  }`
          : `return '${config.default}';`
  }
}

export function getLocalizedPath(path: string, locale: string): string {
  return pathMappings[path]?.[locale] || path;
}

export function useCurrentLocale(): string {
  const location = useLocation();
  
  // Get current locale from TanStack Router location (reactive)
  let currentPath = location.pathname;
  ${
      config.basePath
          ? `const basePath = '${config.basePath}';
  if (currentPath.startsWith(basePath)) {
    currentPath = currentPath.slice(basePath.length) || '/';
  }`
          : ""
  }
  
  // Detect locale from URL path
  const supportedLocales = ${JSON.stringify(config.locales)};
  const detectedLocale = supportedLocales.find(loc => 
    loc !== '${config.default}' && (
      currentPath.startsWith('/' + loc + '/') || 
      currentPath === '/' + loc || 
      currentPath === '/' + loc + '/'
    )
  );
  
  return detectedLocale || '${config.default}';
}

export function useRouteTo() {
  const locale = useCurrentLocale();
  return (id: string, params = {}) => routeTo(id, params, locale);
}`,

    routeIdMappings: (mappings: any) => `export const routeIdMappings = ${JSON.stringify(mappings, null, 2)};`,

    routeTo: (config: {
        hasI18n: boolean;
        forceUrl: boolean;
        default: string;
    }) => `export function routeTo(id: string, params: Record<string, any> = {}, locale?: string): string {
  const route = routeIdMappings[id.toLowerCase()];
  if (!route) return '/';
  
  ${
      config.hasI18n
          ? `// Handle locale based on forceLocaleUrl setting
  if (!locale) {
    ${
        config.forceUrl
            ? `// forceLocaleUrl is enabled - use current detected locale
    locale = getCurrentLocale();`
            : `// forceLocaleUrl is disabled - always use default locale
    locale = '${config.default}';`
    }
  }
  
  // Get the localized path template
  const localizedTemplate = getLocalizedPath(route.path, locale);`
          : `let localizedTemplate = route.path;`
  }
  
  // Fill in parameters
  let finalPath = localizedTemplate;
  Object.entries(params).forEach(([k, v]) => finalPath = finalPath.replace(\`{\${k}}\`, String(v)));
  return finalPath;
}`,

    router: (definitions: string[], routeVariables: string[], basePath?: string, routerConfig?: any) => {
        const configOptions = [];

        if (basePath) {
            configOptions.push(`basepath: '${basePath}'`);
        }

        if (routerConfig?.defaultPreload) {
            configOptions.push(`defaultPreload: '${routerConfig.defaultPreload}'`);
        }

        if (routerConfig?.defaultPreloadStaleTime) {
            configOptions.push(`defaultPreloadStaleTime: ${routerConfig.defaultPreloadStaleTime}`);
        }

        if (routerConfig?.defaultGcTime) {
            configOptions.push(`defaultGcTime: ${routerConfig.defaultGcTime}`);
        }

        const configString = configOptions.length > 0 ? `,\n  ${configOptions.join(",\n  ")}` : "";

        return `const rootRoute = createRootRoute({ 
  component: RootComponent 
});

${definitions.join("\n\n")}

// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];

export const router = createRouter({
  routeTree: rootRoute.addChildren(routes)${configString}
});

declare module '@tanstack/react-router' {
  interface Register { router: typeof router; }
}`;
    },

    routesArray: (routeVariables: string[]) => `// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];`,
};

// 🎨 Route processor with zero waste
function processRoutes(routes: GeneratedRoute[], config: any) {
    const { hasI18n, locales, default: defaultLocale, lazyComponents = false } = config;
    const imports = new Set<string>();
    const componentNameMap = new Map<string, string>();
    const routeDefinitions: string[] = [];
    const routeVariables: string[] = [];
    const localizedRouteDefinitions: string[] = [];
    const localizedRouteVariables: string[] = [];
    const pathMappings: Record<string, Record<string, string>> = {};
    const routeIdMappings: Record<string, any> = {};

    // Generate imports (collect all unique component paths)
    routes.forEach((route) => {
        const allComponents = hasI18n ? Object.values(route.i18nComponents) : [route.component];

        allComponents.forEach((componentPath) => {
            const importPath = generateComponentImportPath(componentPath);
            const componentName =
                componentPath
                    .split("/")
                    .pop()
                    ?.replace(/[^a-zA-Z0-9]/g, "") || "Component";

            if (lazyComponents) {
                imports.add(`const ${componentName} = lazy(() => import('${importPath}'));`);
            } else {
                imports.add(`import ${componentName} from '${importPath}';`);
            }
            componentNameMap.set(componentPath, componentName);
        });
    });

    // Generate route definitions for default locale
    routes.forEach((route) => {
        const componentName = componentNameMap.get(route.component) || "Component";
        const routeVarName = `${generateRouteId(route.id)}Route`; // Use camelCase for variable names
        const routePath = convertYamlPathToTanstackPath(route.path);

        routeDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${routePath}',
  component: ${componentName}
});`);

        routeVariables.push(routeVarName);
    });

    // Generate localized route definitions with locale prefix (only if i18n is enabled)
    if (hasI18n) {
        (locales as string[]).forEach((locale: string) => {
            if (locale === defaultLocale) return; // Skip default locale as it has no prefix

            routes.forEach((route) => {
                const componentPath = route.i18nComponents[locale] || route.component;
                const componentName = componentNameMap.get(componentPath) || "Component";
                const routeVarName = `${generateRouteId(route.id)}${locale.charAt(0).toUpperCase() + locale.slice(1)}Route`;

                // Use the localized path from i18n config if available, otherwise use the base path
                const localizedPath = route.i18nPaths[locale] || route.path;
                const convertedPath = convertYamlPathToTanstackPath(localizedPath);

                // Add locale prefix to the localized path
                const finalPath = `/${locale}${convertedPath}`;

                localizedRouteDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${finalPath}',
  component: ${componentName}
});`);

                localizedRouteVariables.push(routeVarName);
            });
        });
    }

    // Generate path mapping for navigation (only if i18n is enabled)
    if (hasI18n) {
        routes.forEach((route) => {
            const basePath = route.path;
            pathMappings[basePath] = {};
            (locales as string[]).forEach((locale: string) => {
                if (locale === defaultLocale) {
                    pathMappings[basePath][locale] = basePath;
                } else {
                    const localizedPath = route.i18nPaths[locale] || route.path;
                    pathMappings[basePath][locale] = `/${locale}${localizedPath}`;
                }
            });
        });
    }

    // Generate route ID mapping for the routeTo helper
    routes.forEach((route) => {
        const paramNames = Object.keys(route.parameters);

        // Only use the original YAML key - developers should use the same convention
        routeIdMappings[route.id] = {
            path: route.path,
            parameters: paramNames,
        };
    });

    // Build the route tree
    const allRouteVariables = [...routeVariables, ...localizedRouteVariables];
    const allDefinitions = [...routeDefinitions, ...localizedRouteDefinitions];

    return {
        components: Array.from(imports),
        definitions: allDefinitions,
        routeVariables: allRouteVariables,
        pathMappings,
        routeIdMappings,
        config: { hasI18n, forceUrl: config.forceUrl, default: defaultLocale, locales, basePath: config.basePath },
    };
}

export async function generateTanStackRoutes(config: BuildConfig): Promise<void> {
    console.log("🔧 Loading configuration...");
    const routingConfig = await loadRoutingConfig(config.configPath);

    const validation = validateRoutingConfig(routingConfig);
    if (!validation.valid) {
        throw new Error(`❌ Invalid config:\n${validation.errors.join("\n")}`);
    }

    console.log("🚀 Processing routes...");

    // Extract settings
    const globalSettings = routingConfig.settings || {};
    const i18nEnabled = globalSettings.i18n?.enabled ?? true;
    const defaultLocale = globalSettings.i18n?.defaultLocale || config.defaultLocale || "en";
    const supportedLocales = globalSettings.i18n?.supportedLocales || config.supportedLocales || ["en", "fr", "es"];
    const forceLocaleUrl = globalSettings.i18n?.forceLocaleUrl ?? false;
    const lazyComponents = globalSettings.lazyComponents ?? false;
    const routerConfig = globalSettings.router || {};

    console.log(`🌐 i18n: ${i18nEnabled ? "enabled" : "disabled"}, locale: ${defaultLocale}, force: ${forceLocaleUrl}`);
    console.log(`⚡ Lazy components: ${lazyComponents ? "enabled" : "disabled"}`);
    if (Object.keys(routerConfig).length > 0) {
        console.log(`🚀 Router config: ${Object.keys(routerConfig).join(", ")}`);
    }

    // Process routes
    const routes: GeneratedRoute[] = [];
    for (const [name, routeConfig] of Object.entries(routingConfig)) {
        if (name === "settings" || !isRouteConfig(routeConfig)) continue;

        const normalizedName = normalizeRouteName(name);

        const i18nPaths: Record<string, string> = {};
        const i18nComponents: Record<string, string> = {};

        if (i18nEnabled) {
            for (const locale of supportedLocales) {
                i18nPaths[locale] = extractPathValue(routeConfig.path, locale, defaultLocale);
                i18nComponents[locale] = extractComponentValue(routeConfig.component, locale, defaultLocale);
            }
        } else {
            const path = extractPathValue(routeConfig.path, defaultLocale, defaultLocale);
            const component = extractComponentValue(routeConfig.component, defaultLocale, defaultLocale);
            i18nPaths[defaultLocale] = path;
            i18nComponents[defaultLocale] = component;
        }

        routes.push({
            id: normalizedName,
            path: extractPathValue(routeConfig.path, defaultLocale, defaultLocale),
            component: extractComponentValue(routeConfig.component, defaultLocale, defaultLocale),
            parameters: routeConfig.parameters || {},
            i18nPaths,
            i18nComponents,
            settings: routeConfig.settings,
        });
    }

    // Process and generate
    const routeConfig = {
        hasI18n: i18nEnabled,
        locales: supportedLocales,
        default: defaultLocale,
        forceUrl: forceLocaleUrl,
        basePath: globalSettings.basePath,
        lazyComponents,
    };
    const processed = processRoutes(routes, routeConfig);

    // Build final code
    const code = new CodeBuilder()
        .section($.imports(processed.components, i18nEnabled, lazyComponents))
        .section($.settings(globalSettings))
        .section($.i18nCode(processed.config, processed.pathMappings), i18nEnabled)
        .section($.routeIdMappings(processed.routeIdMappings))
        .section($.routeTo(processed.config))
        .section($.router(processed.definitions, processed.routeVariables, globalSettings.basePath, routerConfig))
        .render();

    await writeFile(config.outputPath, code);

    console.log(`✅ Generated: ${config.outputPath}`);
    console.log(`📊 Routes: ${routes.length}${i18nEnabled ? ` (i18n enabled)` : ""}`);
    console.log("🎉 Complete!");
}
