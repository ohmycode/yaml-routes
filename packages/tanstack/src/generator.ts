import { writeFile, readFile } from "fs/promises";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import type { RoutingConfig, GeneratedRoute, Settings, SupportedLocale, BuildConfig } from "./types";
import {
    loadRoutingConfig,
    isRouteConfig,
    convertYamlPathToTanstackPath,
    generateRouteId,
    generateComponentImportPath,
    extractPathValue,
    extractComponentValue,
    normalizeRouteName,
    validateRoutingConfig,
} from "./utils";

// üöÄ Ultra-clean template system - zero boilerplate, maximum power
class CodeBuilder {
    private chunks: string[] = [];

    section(content: string, condition = true): this {
        if (condition && content.trim()) {
            this.chunks.push(content.trim());
        }
        return this;
    }

    render(): string {
        return this.chunks.join("\n\n") + "\n";
    }
}

// üéØ Smart templates that adapt to configuration
const $ = {
    imports: (components: string[], hasI18n: boolean, lazyComponents: boolean = false, routerConfig?: any) => {
        let routerComponentImports = "";

        // Add imports for router components
        if (routerConfig) {
            for (const [key, value] of Object.entries(routerConfig)) {
                if (key.toLowerCase().includes("component") && typeof value === "string") {
                    // Generate PascalCase component name from full path to prevent conflicts
                    // Example: "pages/demo/Home" -> "PagesDemoHome"
                    const componentName = value
                        .split("/")
                        .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, ""))
                        .join("");

                    if (lazyComponents) {
                        routerComponentImports += `\nconst ${componentName} = lazy(() => import('./${value}'));`;
                    } else {
                        routerComponentImports += `\nimport ${componentName} from './${value}';`;
                    }
                }
            }
        }

        return `// Auto-generated by yaml-routes
import { createRootRoute, createRoute, createRouter } from '@tanstack/react-router';${
            lazyComponents
                ? `
import { lazy } from 'react';`
                : ""
        }
import { RootComponent } from './App';${
            hasI18n
                ? `
import { useState, useEffect } from 'react';
import { useLocation, useMatchRoute, useParams } from '@tanstack/react-router';`
                : ""
        }
${components.join("\n")}${routerComponentImports}`;
    },

    settings: (config: any) => `export const settings = ${JSON.stringify(config, null, 2)};`,

    i18nCode: (config: { default: string; locales: string[]; forceUrl: boolean; basePath?: string }, mappings: any = {}) => `// üåç Smart i18n system
export const pathMappings: Record<string, Record<string, string>> = ${JSON.stringify(mappings, null, 2)};

export function getLocalizedPath(path: string, locale: string): string {
  return pathMappings[path]?.[locale] || path;
}

export function useCurrentLocale(): string {
  const location = useLocation();
  
  // Get current locale from TanStack Router location (reactive)
  let currentPath = location.pathname;
  ${
      config.basePath
          ? `const basePath = '${config.basePath}';
  if (currentPath.startsWith(basePath)) {
    currentPath = currentPath.slice(basePath.length) || '/';
  }`
          : ""
  }
  
  // Detect locale from URL path
  const supportedLocales = ${JSON.stringify(config.locales)};
  const detectedLocale = supportedLocales.find(loc => 
    loc !== settings.i18n.defaultLocale && (
      currentPath.startsWith('/' + loc + '/') || 
      currentPath === '/' + loc || 
      currentPath === '/' + loc + '/'
    )
  );
  
  return detectedLocale || settings.i18n.defaultLocale;
}

export function useRouteTo() {
  const locale = useCurrentLocale();
  return (id: string, params = {}) => {
    const route = routeIdMappings[id.toLowerCase()];
    if (!route) return '/';
    
    // Get the localized path template
    const localizedTemplate = getLocalizedPath(route.path, locale);
    
    // Fill in parameters
    let finalPath = localizedTemplate;
    Object.entries(params).forEach(([k, v]) => finalPath = finalPath.replace(\`{\${k}}\`, String(v)));
    return finalPath;
  };
}

export function useRouteName(): string {
  const location = useLocation();
  
  // Use TanStack Router's built-in route matching
  // The pathname already contains the matched route information
  const pathname = location.pathname;
  
  // Quick path normalization
  let normalizedPath = pathname;
  ${
      config.basePath
          ? `if (normalizedPath.startsWith('${config.basePath}')) {
    normalizedPath = normalizedPath.slice(${config.basePath.length}) || '/';
  }`
          : ""
  }
  
  // Remove locale prefix for route matching
  const supportedLocales = ${JSON.stringify(config.locales)};
  for (const locale of supportedLocales) {
    if (locale !== settings.i18n.defaultLocale) {
      const localePrefix = '/' + locale;
      if (normalizedPath === localePrefix || normalizedPath === localePrefix + '/') {
        normalizedPath = '/';
        break;
      } else if (normalizedPath.startsWith(localePrefix + '/')) {
        normalizedPath = normalizedPath.slice(localePrefix.length);
        break;
      }
    }
  }
  
  // Direct lookup in route mappings (most efficient)
  for (const [routeId, routeData] of Object.entries(routeIdMappings)) {
    // Check exact match first (fastest)
    if (routeData.path === normalizedPath) {
      return routeId;
    }
    
    // Check pattern match only if needed
    if (routeData.path.includes('{')) {
      const pathPattern = routeData.path.replace(/{[^}]+}/g, '[^/]+');
      const regex = new RegExp('^' + pathPattern.replace(/\\//g, '\\\\/') + '$');
      if (regex.test(normalizedPath)) {
        return routeId;
      }
    }
  }
  
  return normalizedPath === '/' ? 'home' : 'unknown';
}

export function useRouteParams(includeLocale: boolean = true): Record<string, string> {
  const params = useParams({ strict: false });
  const locale = useCurrentLocale();
  
  if (includeLocale) {
    return {
      ...params,
      locale
    };
  }
  
  return params;
}`,

    routeIdMappings: (mappings: any) =>
        `export const routeIdMappings: Record<string, { path: string; parameters: string[] }> = ${JSON.stringify(mappings, null, 2)};`,

    localeSwitcherHelpers: () => {
        // Directly embed the locale switcher helper functions for React-only environments
        return `
// üîß Helper functions for locale switching (React hooks only)
// Required imports: useLocation from '@tanstack/react-router'
// These functions depend on: settings, pathMappings, routeIdMappings, useRouteTo

export function extractRouteParameters(url: string, pattern: string): Record<string, string> | null {
    const regexPattern = pattern.replace(/\\{([^}]+)\\}/g, "([^/]+)");
    const regex = new RegExp(\`^\${regexPattern}$\`);
    const match = url.match(regex);

    if (!match) return null;

    const paramNames = [...pattern.matchAll(/\\{([^}]+)\\}/g)].map((m) => m[1]);
    const params: Record<string, string> = {};
    paramNames.forEach((name, index) => {
        params[name] = match[index + 1];
    });

    return params;
}

// üîß React hooks for locale switching (using TanStack Router)
export function useCurrentRoute(): { routeId: string; params: Record<string, string> } | null {
    const location = useLocation();

    // Get current URL path from TanStack Router location (reactive)
    const currentPath = location.pathname;
    let pathWithoutBase = currentPath;

    // Remove base path if present
    if (settings.basePath && currentPath.startsWith(settings.basePath)) {
        pathWithoutBase = currentPath.slice(settings.basePath.length) || "/";
    }

    // Try to match current path against all route patterns in pathMappings
    for (const [routePattern, localeMap] of Object.entries(pathMappings)) {
        for (const [locale, localizedPath] of Object.entries(localeMap)) {
            const params = extractRouteParameters(pathWithoutBase, localizedPath);
            if (params !== null) {
                // Found a match! Find the corresponding route ID
                const routeId = Object.keys(routeIdMappings).find((id) => routeIdMappings[id].path === routePattern);
                if (routeId) {
                    return { routeId, params };
                }
            }
        }
    }

    return null;
}

export function useLocalePath(targetLocale: string): string {
    const currentRoute = useCurrentRoute();

    if (currentRoute) {
        // Found the current route - generate URL for target locale
        const routePattern = routeIdMappings[currentRoute.routeId]?.path;
        if (routePattern && pathMappings[routePattern]?.[targetLocale]) {
            const targetPath = pathMappings[routePattern][targetLocale];
            // Replace parameters in the target path
            let finalPath = targetPath;
            for (const [key, value] of Object.entries(currentRoute.params)) {
                finalPath = finalPath.replace('{' + key + '}', value);
            }
            return finalPath;
        }
    }

    // Fallback: go to home page of target locale
    const homePattern = routeIdMappings["home"]?.path;
    if (homePattern && pathMappings[homePattern]?.[targetLocale]) {
        return pathMappings[homePattern][targetLocale];
    }
    
    return "/";
}`.trim();
    },

    router: (definitions: string[], routeVariables: string[], basePath?: string, routerConfig?: any) => {
        const configOptions = [];

        if (basePath) {
            configOptions.push(`basepath: '${basePath}'`);
        }

        // Generic handling of all router config options
        if (routerConfig) {
            for (const [key, value] of Object.entries(routerConfig)) {
                if (value !== undefined && value !== null) {
                    // Handle component references specially
                    if (key.toLowerCase().includes("component") && typeof value === "string") {
                        // Generate PascalCase component name from full path to prevent conflicts
                        // Example: "pages/demo/Home" -> "PagesDemoHome"
                        const componentName = value
                            .split("/")
                            .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, ""))
                            .join("");
                        configOptions.push(`${key}: ${componentName}`);
                    } else {
                        // Regular values
                        const formattedValue = typeof value === "string" ? `'${value}'` : String(value);
                        configOptions.push(`${key}: ${formattedValue}`);
                    }
                }
            }
        }

        const configString = configOptions.length > 0 ? `,\n  ${configOptions.join(",\n  ")}` : "";

        return `const rootRoute = createRootRoute({ 
  component: RootComponent 
});

${definitions.join("\n\n")}

// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];

export const router = createRouter({
  routeTree: rootRoute.addChildren(routes)${configString}
});

declare module '@tanstack/react-router' {
  interface Register { router: typeof router; }
}`;
    },

    routesArray: (routeVariables: string[]) => `// Export all routes in a convenient array
export const routes = [${routeVariables.join(", ")}];`,
};

// üé® Route processor with zero waste
function processRoutes(routes: GeneratedRoute[], config: any) {
    const { hasI18n, locales, default: defaultLocale, lazyComponents = false } = config;
    const imports = new Set<string>();
    const componentNameMap = new Map<string, string>();
    const routeDefinitions: string[] = [];
    const routeVariables: string[] = [];
    const localizedRouteDefinitions: string[] = [];
    const localizedRouteVariables: string[] = [];
    const pathMappings: Record<string, Record<string, string>> = {};
    const routeIdMappings: Record<string, any> = {};

    // Generate imports (collect all unique component paths)
    routes.forEach((route) => {
        const allComponents = hasI18n ? Object.values(route.i18nComponents) : [route.component];

        allComponents.forEach((componentPath) => {
            const importPath = generateComponentImportPath(componentPath);

            // Generate PascalCase component name from full path to prevent conflicts
            // Example: "pages/demo/Home" -> "PagesDemoHome"
            const componentName = componentPath
                .split("/")
                .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1).replace(/[^a-zA-Z0-9]/g, ""))
                .join("");

            if (lazyComponents) {
                imports.add(`const ${componentName} = lazy(() => import('${importPath}'));`);
            } else {
                imports.add(`import ${componentName} from '${importPath}';`);
            }
            componentNameMap.set(componentPath, componentName);
        });
    });

    // Generate route definitions for default locale
    routes.forEach((route) => {
        const componentName = componentNameMap.get(route.component) || "Component";
        const routeVarName = `${generateRouteId(route.id)}Route`; // Use camelCase for variable names
        const routePath = convertYamlPathToTanstackPath(route.path);

        routeDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${routePath}',
  component: ${componentName}
});`);

        routeVariables.push(routeVarName);
    });

    // Generate localized route definitions with locale prefix (only if i18n is enabled)
    if (hasI18n) {
        (locales as string[]).forEach((locale: string) => {
            if (locale === defaultLocale) return; // Skip default locale as it has no prefix

            routes.forEach((route) => {
                const componentPath = route.i18nComponents[locale] || route.component;
                const componentName = componentNameMap.get(componentPath) || "Component";
                const routeVarName = `${generateRouteId(route.id)}${locale.charAt(0).toUpperCase() + locale.slice(1)}Route`;

                // Use the localized path from i18n config if available, otherwise use the base path
                const localizedPath = route.i18nPaths[locale] || route.path;
                const convertedPath = convertYamlPathToTanstackPath(localizedPath);

                // Add locale prefix to the localized path
                const finalPath = `/${locale}${convertedPath}`;

                localizedRouteDefinitions.push(`const ${routeVarName} = createRoute({
  getParentRoute: () => rootRoute,
  path: '${finalPath}',
  component: ${componentName}
});`);

                localizedRouteVariables.push(routeVarName);
            });
        });
    }

    // Generate path mapping for navigation (only if i18n is enabled)
    if (hasI18n) {
        routes.forEach((route) => {
            const basePath = route.path;
            pathMappings[basePath] = {};
            (locales as string[]).forEach((locale: string) => {
                if (locale === defaultLocale) {
                    pathMappings[basePath][locale] = basePath;
                } else {
                    const localizedPath = route.i18nPaths[locale] || route.path;
                    pathMappings[basePath][locale] = `/${locale}${localizedPath}`;
                }
            });
        });
    }

    // Generate route ID mapping for the routeTo helper
    routes.forEach((route) => {
        const paramNames = Object.keys(route.parameters);

        // Only use the original YAML key - developers should use the same convention
        routeIdMappings[route.id] = {
            path: route.path,
            parameters: paramNames,
        };
    });

    // Build the route tree
    const allRouteVariables = [...routeVariables, ...localizedRouteVariables];
    const allDefinitions = [...routeDefinitions, ...localizedRouteDefinitions];

    return {
        components: Array.from(imports),
        definitions: allDefinitions,
        routeVariables: allRouteVariables,
        pathMappings,
        routeIdMappings,
        config: { hasI18n, forceUrl: config.forceUrl, default: defaultLocale, locales, basePath: config.basePath },
    };
}

export async function generateTanStackRoutes(config: BuildConfig): Promise<void> {
    console.log("üîß Loading configuration...");
    const routingConfig = await loadRoutingConfig(config.configPath);

    const validation = validateRoutingConfig(routingConfig);
    if (!validation.valid) {
        throw new Error(`‚ùå Invalid config:\n${validation.errors.join("\n")}`);
    }

    console.log("üöÄ Processing routes...");

    // Extract settings
    const settings = routingConfig.settings || {};
    const i18nEnabled = settings.i18n?.enabled ?? true;
    const defaultLocale = settings.i18n?.defaultLocale || config.defaultLocale || "en";
    const supportedLocales = settings.i18n?.supportedLocales || config.supportedLocales || ["en", "fr", "es"];
    const forceLocaleUrl = settings.i18n?.forceLocaleUrl ?? false;
    const lazyComponents = settings.lazyComponents ?? false;
    const routerConfig = settings.router || {};

    console.log(`üåê i18n: ${i18nEnabled ? "enabled" : "disabled"}, locale: ${defaultLocale}, force: ${forceLocaleUrl}`);
    console.log(`‚ö° Lazy components: ${lazyComponents ? "enabled" : "disabled"}`);
    if (Object.keys(routerConfig).length > 0) {
        console.log(`üöÄ Router config: ${Object.keys(routerConfig).join(", ")}`);
    }

    // Process routes
    const routes: GeneratedRoute[] = [];
    for (const [name, routeConfig] of Object.entries(routingConfig)) {
        if (name === "settings" || !isRouteConfig(routeConfig)) continue;

        const normalizedName = normalizeRouteName(name);

        const i18nPaths: Record<string, string> = {};
        const i18nComponents: Record<string, string> = {};

        if (i18nEnabled) {
            for (const locale of supportedLocales) {
                i18nPaths[locale] = extractPathValue(routeConfig.path, locale, defaultLocale);
                i18nComponents[locale] = extractComponentValue(routeConfig.component, locale, defaultLocale);
            }
        } else {
            const path = extractPathValue(routeConfig.path, defaultLocale, defaultLocale);
            const component = extractComponentValue(routeConfig.component, defaultLocale, defaultLocale);
            i18nPaths[defaultLocale] = path;
            i18nComponents[defaultLocale] = component;
        }

        routes.push({
            id: normalizedName,
            path: extractPathValue(routeConfig.path, defaultLocale, defaultLocale),
            component: extractComponentValue(routeConfig.component, defaultLocale, defaultLocale),
            parameters: routeConfig.parameters || {},
            i18nPaths,
            i18nComponents,
            settings: routeConfig.settings,
        });
    }

    // Process and generate
    const routeConfig = {
        hasI18n: i18nEnabled,
        locales: supportedLocales,
        default: defaultLocale,
        forceUrl: forceLocaleUrl,
        basePath: settings.basePath,
        lazyComponents,
    };
    const processed = processRoutes(routes, routeConfig);

    // Build final code
    const code = new CodeBuilder()
        .section($.imports(processed.components, i18nEnabled, lazyComponents, routerConfig))
        .section($.settings(settings))
        .section($.i18nCode(processed.config, processed.pathMappings), i18nEnabled)
        .section($.routeIdMappings(processed.routeIdMappings))
        .section($.localeSwitcherHelpers(), i18nEnabled)
        .section($.router(processed.definitions, processed.routeVariables, settings.basePath, routerConfig))
        .render();

    await writeFile(config.outputPath, code);

    console.log(`‚úÖ Generated: ${config.outputPath}`);
    console.log(`üìä Routes: ${routes.length}${i18nEnabled ? ` (i18n enabled)` : ""}`);
    console.log("üéâ Complete!");
}
